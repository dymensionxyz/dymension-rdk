// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: gasless/v1beta1/gasless.proto

package types

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// UsageIdentifierToGasTankIds maps all the gas tank ids with the usage identifier
// results in faster query of gas tanks based on usage identifier
type UsageIdentifierToGasTankIds struct {
	// usage identifier defines the unique identifier for a tx
	UsageIdentifier string `protobuf:"bytes,1,opt,name=usage_identifier,json=usageIdentifier,proto3" json:"usage_identifier,omitempty"`
	// all the associated gas tank ids for the usage identifier
	GasTankIds []uint64 `protobuf:"varint,2,rep,packed,name=gas_tank_ids,json=gasTankIds,proto3" json:"gas_tank_ids,omitempty"`
}

func (m *UsageIdentifierToGasTankIds) Reset()         { *m = UsageIdentifierToGasTankIds{} }
func (m *UsageIdentifierToGasTankIds) String() string { return proto.CompactTextString(m) }
func (*UsageIdentifierToGasTankIds) ProtoMessage()    {}
func (*UsageIdentifierToGasTankIds) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ad54f7cdbbcb409, []int{0}
}
func (m *UsageIdentifierToGasTankIds) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageIdentifierToGasTankIds) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageIdentifierToGasTankIds.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageIdentifierToGasTankIds) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageIdentifierToGasTankIds.Merge(m, src)
}
func (m *UsageIdentifierToGasTankIds) XXX_Size() int {
	return m.Size()
}
func (m *UsageIdentifierToGasTankIds) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageIdentifierToGasTankIds.DiscardUnknown(m)
}

var xxx_messageInfo_UsageIdentifierToGasTankIds proto.InternalMessageInfo

// GasTank defines the store for all the configurations of a set by a gas provider
type GasTank struct {
	// id defines the id of gas tank
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// provider defines the creator/owner of the gas tank
	Provider string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	// reserve defines the reserve address of the gas tank where deposited funds are stored
	Reserve string `protobuf:"bytes,3,opt,name=reserve,proto3" json:"reserve,omitempty"`
	// status of the gas tank if it is active or not
	IsActive bool `protobuf:"varint,4,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	// max_fee_usage_per_consumer defines the gas consumption limit which consumer is allowed, beyod this limit gas tank will not sponsor the tx
	MaxFeeUsagePerConsumer github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,5,opt,name=max_fee_usage_per_consumer,json=maxFeeUsagePerConsumer,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_fee_usage_per_consumer"`
	// max_fee_usage_per_tx defines the maximum limit for the fee ased by the tx, beyond this gastank cannot sponsor the tx
	MaxFeeUsagePerTx github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,6,opt,name=max_fee_usage_per_tx,json=maxFeeUsagePerTx,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"max_fee_usage_per_tx"`
	// usage_identifiers defines the unique list of MessageTypes,ContractAddress or any valid usage identifier which are whitelisted by gas tank.
	UsageIdentifiers []string `protobuf:"bytes,7,rep,name=usage_identifiers,json=usageIdentifiers,proto3" json:"usage_identifiers,omitempty"`
	// fee_denom defines the supported fee denom by gas tank.
	FeeDenom string `protobuf:"bytes,8,opt,name=fee_denom,json=feeDenom,proto3" json:"fee_denom,omitempty"`
}

func (m *GasTank) Reset()         { *m = GasTank{} }
func (m *GasTank) String() string { return proto.CompactTextString(m) }
func (*GasTank) ProtoMessage()    {}
func (*GasTank) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ad54f7cdbbcb409, []int{1}
}
func (m *GasTank) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasTank) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasTank.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasTank) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasTank.Merge(m, src)
}
func (m *GasTank) XXX_Size() int {
	return m.Size()
}
func (m *GasTank) XXX_DiscardUnknown() {
	xxx_messageInfo_GasTank.DiscardUnknown(m)
}

var xxx_messageInfo_GasTank proto.InternalMessageInfo

// GasConsumer > ConsumptionDetail > Usage > Detail stores the consumption activity of the consumer
type Detail struct {
	// timestamp defines the timestamp at which the fee was consumed
	Timestamp time.Time `protobuf:"bytes,1,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	// gas_consumed defines the amount of fee consumed by the tx
	GasConsumed github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=gas_consumed,json=gasConsumed,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"gas_consumed"`
}

func (m *Detail) Reset()         { *m = Detail{} }
func (m *Detail) String() string { return proto.CompactTextString(m) }
func (*Detail) ProtoMessage()    {}
func (*Detail) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ad54f7cdbbcb409, []int{2}
}
func (m *Detail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Detail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Detail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Detail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Detail.Merge(m, src)
}
func (m *Detail) XXX_Size() int {
	return m.Size()
}
func (m *Detail) XXX_DiscardUnknown() {
	xxx_messageInfo_Detail.DiscardUnknown(m)
}

var xxx_messageInfo_Detail proto.InternalMessageInfo

// GasConsumer > ConsumptionDetail > Usage defines the independent usage of gas by the individual usage identifier
type Usage struct {
	// usage identifier defines the gas consumption/usage identifier of the tx, this identifier is responsible for consuming gas
	UsageIdentifier string `protobuf:"bytes,1,opt,name=usage_identifier,json=usageIdentifier,proto3" json:"usage_identifier,omitempty"`
	// details defines the list of usage details by the usage identifier along with fee amount and timestamp
	Details []*Detail `protobuf:"bytes,2,rep,name=details,proto3" json:"details,omitempty"`
}

func (m *Usage) Reset()         { *m = Usage{} }
func (m *Usage) String() string { return proto.CompactTextString(m) }
func (*Usage) ProtoMessage()    {}
func (*Usage) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ad54f7cdbbcb409, []int{3}
}
func (m *Usage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Usage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Usage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Usage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Usage.Merge(m, src)
}
func (m *Usage) XXX_Size() int {
	return m.Size()
}
func (m *Usage) XXX_DiscardUnknown() {
	xxx_messageInfo_Usage.DiscardUnknown(m)
}

var xxx_messageInfo_Usage proto.InternalMessageInfo

// GasConsumer > ConsumptionDetail defines the usage statistics of the consumer within each gas tank
type ConsumptionDetail struct {
	// gas_tank_id defines the if of the gas tank
	GasTankId uint64 `protobuf:"varint,1,opt,name=gas_tank_id,json=gasTankId,proto3" json:"gas_tank_id,omitempty"`
	// is_blocked defines if the consumer is blocked or not by the gas tank
	IsBlocked bool `protobuf:"varint,2,opt,name=is_blocked,json=isBlocked,proto3" json:"is_blocked,omitempty"`
	// total_fee_consumption_allowed defines the maximum fee consumption allowed by the gas tank to the consumer
	TotalFeeConsumptionAllowed github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=total_fee_consumption_allowed,json=totalFeeConsumptionAllowed,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_fee_consumption_allowed"`
	// total_fees_consumed defines the total fee consumed so far by the consumer in this gas tank
	TotalFeesConsumed github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,4,opt,name=total_fees_consumed,json=totalFeesConsumed,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"total_fees_consumed"`
	// usage defines the usage of gas within this gas tank
	Usage []*Usage `protobuf:"bytes,5,rep,name=usage,proto3" json:"usage,omitempty"`
}

func (m *ConsumptionDetail) Reset()         { *m = ConsumptionDetail{} }
func (m *ConsumptionDetail) String() string { return proto.CompactTextString(m) }
func (*ConsumptionDetail) ProtoMessage()    {}
func (*ConsumptionDetail) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ad54f7cdbbcb409, []int{4}
}
func (m *ConsumptionDetail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsumptionDetail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsumptionDetail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsumptionDetail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsumptionDetail.Merge(m, src)
}
func (m *ConsumptionDetail) XXX_Size() int {
	return m.Size()
}
func (m *ConsumptionDetail) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsumptionDetail.DiscardUnknown(m)
}

var xxx_messageInfo_ConsumptionDetail proto.InternalMessageInfo

// GasConsumer stores the consumer address and all the gas consumption activities within the gas tank
type GasConsumer struct {
	// bech32 encoded address of the consumer
	Consumer string `protobuf:"bytes,1,opt,name=consumer,proto3" json:"consumer,omitempty"`
	// consumtion statistics of the consumer
	Consumptions []*ConsumptionDetail `protobuf:"bytes,2,rep,name=consumptions,proto3" json:"consumptions,omitempty"`
}

func (m *GasConsumer) Reset()         { *m = GasConsumer{} }
func (m *GasConsumer) String() string { return proto.CompactTextString(m) }
func (*GasConsumer) ProtoMessage()    {}
func (*GasConsumer) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ad54f7cdbbcb409, []int{5}
}
func (m *GasConsumer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GasConsumer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GasConsumer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GasConsumer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GasConsumer.Merge(m, src)
}
func (m *GasConsumer) XXX_Size() int {
	return m.Size()
}
func (m *GasConsumer) XXX_DiscardUnknown() {
	xxx_messageInfo_GasConsumer.DiscardUnknown(m)
}

var xxx_messageInfo_GasConsumer proto.InternalMessageInfo

func init() {
	proto.RegisterType((*UsageIdentifierToGasTankIds)(nil), "rollapp.gasless.v1beta1.UsageIdentifierToGasTankIds")
	proto.RegisterType((*GasTank)(nil), "rollapp.gasless.v1beta1.GasTank")
	proto.RegisterType((*Detail)(nil), "rollapp.gasless.v1beta1.Detail")
	proto.RegisterType((*Usage)(nil), "rollapp.gasless.v1beta1.Usage")
	proto.RegisterType((*ConsumptionDetail)(nil), "rollapp.gasless.v1beta1.ConsumptionDetail")
	proto.RegisterType((*GasConsumer)(nil), "rollapp.gasless.v1beta1.GasConsumer")
}

func init() { proto.RegisterFile("gasless/v1beta1/gasless.proto", fileDescriptor_6ad54f7cdbbcb409) }

var fileDescriptor_6ad54f7cdbbcb409 = []byte{
	// 676 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0x8d, 0xf3, 0xd3, 0x24, 0x93, 0xea, 0xfb, 0xda, 0xa1, 0x02, 0x2b, 0x55, 0x9d, 0x28, 0x0b,
	0x14, 0x40, 0xb5, 0xd5, 0x02, 0x0b, 0x96, 0x0d, 0x55, 0xab, 0x6e, 0x10, 0x98, 0xb0, 0x61, 0x51,
	0x6b, 0x12, 0xdf, 0x98, 0x69, 0x6c, 0x8f, 0xf1, 0x4c, 0x42, 0xc2, 0x92, 0x27, 0xe8, 0x1b, 0xf0,
	0x3a, 0x5d, 0x76, 0x89, 0x40, 0x2a, 0xd0, 0xbe, 0x08, 0xf2, 0x8c, 0xed, 0xa6, 0xad, 0xba, 0x68,
	0x57, 0xc9, 0xf5, 0xdc, 0x39, 0xc7, 0xf7, 0x9c, 0x73, 0x8d, 0x36, 0x3c, 0xc2, 0x7d, 0xe0, 0xdc,
	0x9a, 0x6e, 0x0d, 0x40, 0x90, 0x2d, 0x2b, 0xad, 0xcd, 0x28, 0x66, 0x82, 0xe1, 0x47, 0x31, 0xf3,
	0x7d, 0x12, 0x45, 0x66, 0xf6, 0x38, 0x6d, 0x6b, 0xae, 0x79, 0xcc, 0x63, 0xb2, 0xc7, 0x4a, 0xfe,
	0xa9, 0xf6, 0x66, 0xcb, 0x63, 0xcc, 0xf3, 0xc1, 0x92, 0xd5, 0x60, 0x32, 0xb2, 0x04, 0x0d, 0x80,
	0x0b, 0x12, 0x44, 0xaa, 0xa1, 0x73, 0x84, 0xd6, 0x3f, 0x70, 0xe2, 0xc1, 0x81, 0x0b, 0xa1, 0xa0,
	0x23, 0x0a, 0x71, 0x9f, 0xed, 0x13, 0xde, 0x27, 0xe1, 0xf8, 0xc0, 0xe5, 0xf8, 0x09, 0x5a, 0x99,
	0x24, 0xc7, 0x0e, 0xcd, 0xcf, 0x75, 0xad, 0xad, 0x75, 0xeb, 0xf6, 0xff, 0x93, 0xab, 0xd7, 0x70,
	0x1b, 0x2d, 0x7b, 0x84, 0x3b, 0x82, 0x84, 0x63, 0x87, 0xba, 0x5c, 0x2f, 0xb6, 0x4b, 0xdd, 0xb2,
	0x8d, 0xbc, 0x1c, 0xac, 0xf3, 0xad, 0x84, 0xaa, 0x29, 0x36, 0xfe, 0x0f, 0x15, 0xa9, 0x2b, 0xa1,
	0xca, 0x76, 0x91, 0xba, 0xb8, 0x89, 0x6a, 0x51, 0xcc, 0xa6, 0xd4, 0x85, 0x58, 0x2f, 0x4a, 0x82,
	0xbc, 0xc6, 0x3a, 0xaa, 0xc6, 0xc0, 0x21, 0x9e, 0x82, 0x5e, 0x92, 0x47, 0x59, 0x89, 0xd7, 0x51,
	0x9d, 0x72, 0x87, 0x0c, 0x05, 0x9d, 0x82, 0x5e, 0x6e, 0x6b, 0xdd, 0x9a, 0x5d, 0xa3, 0x7c, 0x47,
	0xd6, 0xf8, 0x08, 0x35, 0x03, 0x32, 0x73, 0x46, 0x00, 0x8e, 0x9a, 0x21, 0x82, 0xd8, 0x19, 0xb2,
	0x90, 0x4f, 0x02, 0x88, 0xf5, 0x4a, 0x82, 0xd4, 0x33, 0x4f, 0xce, 0x5a, 0x85, 0x9f, 0x67, 0xad,
	0xc7, 0x1e, 0x15, 0x9f, 0x26, 0x03, 0x73, 0xc8, 0x02, 0x6b, 0xc8, 0x78, 0xc0, 0x78, 0xfa, 0xb3,
	0xc9, 0xdd, 0xb1, 0x25, 0xe6, 0x11, 0x70, 0xf3, 0x20, 0x14, 0xf6, 0xc3, 0x80, 0xcc, 0xf6, 0x00,
	0xa4, 0x64, 0x6f, 0x21, 0x7e, 0x9d, 0xa2, 0xe1, 0x43, 0xb4, 0x76, 0x93, 0x4b, 0xcc, 0xf4, 0xa5,
	0x7b, 0xb1, 0xac, 0x5c, 0x65, 0xe9, 0xcf, 0xf0, 0x33, 0xb4, 0x7a, 0xdd, 0x07, 0xae, 0x57, 0xdb,
	0xa5, 0x6e, 0xdd, 0x5e, 0xb9, 0x66, 0x04, 0x4f, 0x54, 0x49, 0x5e, 0xc4, 0x85, 0x90, 0x05, 0x7a,
	0x4d, 0x89, 0x39, 0x02, 0xd8, 0x4d, 0xea, 0xce, 0x77, 0x0d, 0x2d, 0xed, 0x82, 0x20, 0xd4, 0xc7,
	0x3d, 0x54, 0xcf, 0xe3, 0x20, 0xad, 0x68, 0x6c, 0x37, 0x4d, 0x15, 0x18, 0x33, 0x0b, 0x8c, 0xd9,
	0xcf, 0x3a, 0x7a, 0xb5, 0x64, 0x8a, 0xe3, 0xdf, 0x2d, 0xcd, 0xbe, 0xbc, 0x86, 0xdf, 0x29, 0xd7,
	0x53, 0x59, 0x5d, 0xe5, 0xdd, 0x9d, 0x07, 0x6e, 0x78, 0x84, 0xa7, 0x5a, 0xba, 0x9d, 0x00, 0x55,
	0xe4, 0xe4, 0x77, 0x09, 0xdf, 0x2b, 0x54, 0x75, 0xe5, 0x50, 0x2a, 0x77, 0x8d, 0xed, 0x96, 0x79,
	0xcb, 0xa2, 0x98, 0x6a, 0x78, 0x3b, 0xeb, 0xef, 0xfc, 0x2a, 0xa2, 0x55, 0xc5, 0x1d, 0x09, 0xca,
	0xc2, 0x54, 0x1b, 0x03, 0x35, 0x16, 0xd2, 0x9c, 0x06, 0xb5, 0x9e, 0x87, 0x19, 0x6f, 0x20, 0x44,
	0xb9, 0x33, 0xf0, 0xd9, 0x70, 0x9c, 0x4e, 0x5d, 0xb3, 0xeb, 0x94, 0xf7, 0xd4, 0x03, 0xfc, 0x19,
	0x6d, 0x08, 0x26, 0x88, 0x2f, 0x13, 0x31, 0xbc, 0x44, 0x77, 0x88, 0xef, 0xb3, 0x2f, 0xe0, 0xaa,
	0x20, 0xdf, 0x59, 0xa7, 0xa6, 0x04, 0xdd, 0x03, 0x58, 0x78, 0xe1, 0x1d, 0x85, 0x88, 0x0f, 0xd1,
	0x83, 0x9c, 0x72, 0xc1, 0x90, 0xf2, 0xbd, 0x88, 0x56, 0x33, 0xa2, 0xdc, 0x16, 0xfc, 0x02, 0x55,
	0xa4, 0xea, 0x7a, 0x45, 0x0a, 0x6c, 0xdc, 0x2a, 0xb0, 0x34, 0xcf, 0x56, 0xcd, 0x9d, 0x39, 0x6a,
	0xec, 0xe7, 0xde, 0xc6, 0xc9, 0x9a, 0xe7, 0x1b, 0xa8, 0xac, 0xcc, 0x6b, 0xfc, 0x06, 0x2d, 0x2f,
	0x28, 0x95, 0x19, 0xf9, 0xf4, 0x56, 0x9e, 0x1b, 0xa6, 0xd9, 0x57, 0xee, 0xf7, 0xde, 0x9f, 0xfc,
	0x35, 0x0a, 0x27, 0xe7, 0x86, 0x76, 0x7a, 0x6e, 0x68, 0x7f, 0xce, 0x0d, 0xed, 0xf8, 0xc2, 0x28,
	0x9c, 0x5e, 0x18, 0x85, 0x1f, 0x17, 0x46, 0xe1, 0xe3, 0xcb, 0x05, 0x25, 0xdc, 0x79, 0x00, 0x21,
	0xa7, 0x2c, 0x9c, 0xcd, 0xbf, 0x5e, 0x16, 0x9b, 0xb1, 0x3b, 0xb6, 0x66, 0xd9, 0xf7, 0x57, 0x89,
	0x33, 0x58, 0x92, 0x8b, 0xf1, 0xfc, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x62, 0xc1, 0xb8, 0x2f,
	0xa7, 0x05, 0x00, 0x00,
}

func (m *UsageIdentifierToGasTankIds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageIdentifierToGasTankIds) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageIdentifierToGasTankIds) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GasTankIds) > 0 {
		dAtA2 := make([]byte, len(m.GasTankIds)*10)
		var j1 int
		for _, num := range m.GasTankIds {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintGasless(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UsageIdentifier) > 0 {
		i -= len(m.UsageIdentifier)
		copy(dAtA[i:], m.UsageIdentifier)
		i = encodeVarintGasless(dAtA, i, uint64(len(m.UsageIdentifier)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GasTank) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasTank) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasTank) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FeeDenom) > 0 {
		i -= len(m.FeeDenom)
		copy(dAtA[i:], m.FeeDenom)
		i = encodeVarintGasless(dAtA, i, uint64(len(m.FeeDenom)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.UsageIdentifiers) > 0 {
		for iNdEx := len(m.UsageIdentifiers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UsageIdentifiers[iNdEx])
			copy(dAtA[i:], m.UsageIdentifiers[iNdEx])
			i = encodeVarintGasless(dAtA, i, uint64(len(m.UsageIdentifiers[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	{
		size := m.MaxFeeUsagePerTx.Size()
		i -= size
		if _, err := m.MaxFeeUsagePerTx.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGasless(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.MaxFeeUsagePerConsumer.Size()
		i -= size
		if _, err := m.MaxFeeUsagePerConsumer.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGasless(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Reserve) > 0 {
		i -= len(m.Reserve)
		copy(dAtA[i:], m.Reserve)
		i = encodeVarintGasless(dAtA, i, uint64(len(m.Reserve)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintGasless(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintGasless(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Detail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Detail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Detail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.GasConsumed.Size()
		i -= size
		if _, err := m.GasConsumed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGasless(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintGasless(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Usage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Usage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Usage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Details) > 0 {
		for iNdEx := len(m.Details) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Details[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGasless(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.UsageIdentifier) > 0 {
		i -= len(m.UsageIdentifier)
		copy(dAtA[i:], m.UsageIdentifier)
		i = encodeVarintGasless(dAtA, i, uint64(len(m.UsageIdentifier)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsumptionDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsumptionDetail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsumptionDetail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Usage) > 0 {
		for iNdEx := len(m.Usage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Usage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGasless(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	{
		size := m.TotalFeesConsumed.Size()
		i -= size
		if _, err := m.TotalFeesConsumed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGasless(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TotalFeeConsumptionAllowed.Size()
		i -= size
		if _, err := m.TotalFeeConsumptionAllowed.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintGasless(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.IsBlocked {
		i--
		if m.IsBlocked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.GasTankId != 0 {
		i = encodeVarintGasless(dAtA, i, uint64(m.GasTankId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GasConsumer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GasConsumer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GasConsumer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Consumptions) > 0 {
		for iNdEx := len(m.Consumptions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Consumptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGasless(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Consumer) > 0 {
		i -= len(m.Consumer)
		copy(dAtA[i:], m.Consumer)
		i = encodeVarintGasless(dAtA, i, uint64(len(m.Consumer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintGasless(dAtA []byte, offset int, v uint64) int {
	offset -= sovGasless(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UsageIdentifierToGasTankIds) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UsageIdentifier)
	if l > 0 {
		n += 1 + l + sovGasless(uint64(l))
	}
	if len(m.GasTankIds) > 0 {
		l = 0
		for _, e := range m.GasTankIds {
			l += sovGasless(uint64(e))
		}
		n += 1 + sovGasless(uint64(l)) + l
	}
	return n
}

func (m *GasTank) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGasless(uint64(m.Id))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovGasless(uint64(l))
	}
	l = len(m.Reserve)
	if l > 0 {
		n += 1 + l + sovGasless(uint64(l))
	}
	if m.IsActive {
		n += 2
	}
	l = m.MaxFeeUsagePerConsumer.Size()
	n += 1 + l + sovGasless(uint64(l))
	l = m.MaxFeeUsagePerTx.Size()
	n += 1 + l + sovGasless(uint64(l))
	if len(m.UsageIdentifiers) > 0 {
		for _, s := range m.UsageIdentifiers {
			l = len(s)
			n += 1 + l + sovGasless(uint64(l))
		}
	}
	l = len(m.FeeDenom)
	if l > 0 {
		n += 1 + l + sovGasless(uint64(l))
	}
	return n
}

func (m *Detail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovGasless(uint64(l))
	l = m.GasConsumed.Size()
	n += 1 + l + sovGasless(uint64(l))
	return n
}

func (m *Usage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UsageIdentifier)
	if l > 0 {
		n += 1 + l + sovGasless(uint64(l))
	}
	if len(m.Details) > 0 {
		for _, e := range m.Details {
			l = e.Size()
			n += 1 + l + sovGasless(uint64(l))
		}
	}
	return n
}

func (m *ConsumptionDetail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GasTankId != 0 {
		n += 1 + sovGasless(uint64(m.GasTankId))
	}
	if m.IsBlocked {
		n += 2
	}
	l = m.TotalFeeConsumptionAllowed.Size()
	n += 1 + l + sovGasless(uint64(l))
	l = m.TotalFeesConsumed.Size()
	n += 1 + l + sovGasless(uint64(l))
	if len(m.Usage) > 0 {
		for _, e := range m.Usage {
			l = e.Size()
			n += 1 + l + sovGasless(uint64(l))
		}
	}
	return n
}

func (m *GasConsumer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Consumer)
	if l > 0 {
		n += 1 + l + sovGasless(uint64(l))
	}
	if len(m.Consumptions) > 0 {
		for _, e := range m.Consumptions {
			l = e.Size()
			n += 1 + l + sovGasless(uint64(l))
		}
	}
	return n
}

func sovGasless(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGasless(x uint64) (n int) {
	return sovGasless(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UsageIdentifierToGasTankIds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGasless
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsageIdentifierToGasTankIds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsageIdentifierToGasTankIds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGasless
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GasTankIds = append(m.GasTankIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGasless
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGasless
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGasless
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GasTankIds) == 0 {
					m.GasTankIds = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGasless
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GasTankIds = append(m.GasTankIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GasTankIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGasless(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGasless
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasTank) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGasless
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasTank: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasTank: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserve", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserve = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFeeUsagePerConsumer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxFeeUsagePerConsumer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFeeUsagePerTx", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxFeeUsagePerTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageIdentifiers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageIdentifiers = append(m.UsageIdentifiers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeeDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FeeDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGasless(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGasless
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Detail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGasless
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Detail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Detail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasConsumed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GasConsumed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGasless(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGasless
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Usage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGasless
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Usage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Usage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, &Detail{})
			if err := m.Details[len(m.Details)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGasless(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGasless
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsumptionDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGasless
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsumptionDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsumptionDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasTankId", wireType)
			}
			m.GasTankId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasTankId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBlocked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBlocked = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFeeConsumptionAllowed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalFeeConsumptionAllowed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFeesConsumed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalFeesConsumed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usage = append(m.Usage, &Usage{})
			if err := m.Usage[len(m.Usage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGasless(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGasless
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GasConsumer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGasless
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GasConsumer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GasConsumer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consumer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Consumer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consumptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGasless
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGasless
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Consumptions = append(m.Consumptions, &ConsumptionDetail{})
			if err := m.Consumptions[len(m.Consumptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGasless(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthGasless
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGasless(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGasless
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGasless
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGasless
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGasless
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGasless
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGasless        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGasless          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGasless = fmt.Errorf("proto: unexpected end of group")
)
