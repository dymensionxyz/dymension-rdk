syntax = "proto3";
package rollapp.sequencers.types;

import "gogoproto/gogo.proto";
import "cosmos/staking/v1beta1/staking.proto";
//import "types/tendermint/crypto/keys.proto";
import "cosmos/msg/v1/msg.proto";
import "google/protobuf/any.proto";

// TODO: use sequencer object?
// Sequencer - only the
// cosmos.staking.v1beta1.Validator sequencer = 1
// [ (gogoproto.nullable) = false ];

option go_package = "github.com/dymensionxyz/dymension-rdk/x/sequencers/types";

// Msg defines the Msg service.
service Msg {
    rpc CreateSequencer(MsgCreateSequencer) returns (MsgCreateSequencerResponse);
    rpc UpdateSequencer(MsgUpdateSequencer) returns (MsgUpdateSequencerResponse);
}

// PayloadToSign is marshalled and signed
message PayloadToSign {
    // PayloadApp is application specific signed data
    bytes payload_app = 1;
    // ChainId will be verified against processing chain
    string chain_id = 2;
    // AccountNumber is the auth account keeper account number, it is verified against the message creator
    uint64 account_number = 3;
}

message KeyAndSig {
    google.protobuf.Any pub_key = 1;
//    tendermint.crypto.PublicKey pub_key = 1 [(gogoproto.nullable) = false];
    bytes signature = 2; // signature for some <payload, chain id, account number, account addr, sequence num> // TODO: not seq num
}

message CreateSequencerPayload {
    string operator_addr = 1; // TODO: document
}

message MsgCreateSequencer {
    option (cosmos.msg.v1.signer) = "creator";
    // Creator is the bech32-encoded address of the actor sending the update
    string creator = 1;
    // KeyAndSig has the cons key of the sequencer, as well as a sig over the payload and some replay protection metadata
    KeyAndSig key_and_sig = 2;
    // Payload - signature is in key and sig
    CreateSequencerPayload payload = 3;
}

message MsgCreateSequencerResponse {

}

message UpdateSequencerPayload {
    string reward_addr = 1;
}

message MsgUpdateSequencer {
    option (cosmos.msg.v1.signer) = "creator";
    // Creator is the bech32-encoded address of the actor sending the update
    string creator = 1;
    // KeyAndSig has the cons key of the sequencer, as well as a sig over the payload and some replay protection metadata
    KeyAndSig key_and_sig = 2;
    // Payload - signature is in key and sig
    UpdateSequencerPayload payload = 3;
}

message MsgUpdateSequencerResponse {

}
