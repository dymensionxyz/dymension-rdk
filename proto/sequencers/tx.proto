syntax = "proto3";
package rollapp.sequencers.types;

import "gogoproto/gogo.proto";
import "cosmos/staking/v1beta1/staking.proto";
import "cosmos/msg/v1/msg.proto";
import "google/protobuf/any.proto";

option go_package = "github.com/dymensionxyz/dymension-rdk/x/sequencers/types";

// Msg defines the Msg service.
service Msg {
    rpc CreateSequencer(MsgCreateSequencer) returns (MsgCreateSequencerResponse);
    rpc UpdateSequencer(MsgUpdateSequencer) returns (MsgUpdateSequencerResponse);
}

// PayloadToSign is marshalled and signed. Note, this is not included in the message, but is used to generate
// the signature which is included in the message, and to verify that signature on chain.
message PayloadToSign {
    // PayloadApp is application specific signed data
    bytes payload_app = 1;
    // ChainId will be verified against processing chain
    string chain_id = 2;
    // AccountNumber is the auth account keeper account number, it is verified against the message creator
    uint64 account_number = 3;
}

message KeyAndSig {
    // PubKey is a tendermint consensus pub key
    google.protobuf.Any pub_key = 1;
    // Signature is some signed payload=<app payload, chain id, account number> with priv key of pub key
    bytes signature = 2;
}

message CreateSequencerPayload {
    // OperatorAddr is a bech32 encoded sdk val addr
    string operator_addr = 1;
}

message MsgCreateSequencer {
    option (cosmos.msg.v1.signer) = "operator";
    // Operator is the bech32-encoded address of the actor sending the update - must be val addr
    string operator = 1;
    // KeyAndSig has the cons key of the sequencer, as well as a sig over the payload and some replay protection metadata
    KeyAndSig key_and_sig = 2;
    // Payload - signature is in key and sig
    CreateSequencerPayload payload = 3;
}

message MsgCreateSequencerResponse {

}

message UpdateSequencerPayload {
    // RewardAddr is a bech32 encoded sdk acc address
    string reward_addr = 1;
}

message MsgUpdateSequencer {
    option (cosmos.msg.v1.signer) = "operator";
    // Operator is the bech32-encoded address of the actor sending the update - must be val addr
    string operator = 1;
    // KeyAndSig has the cons key of the sequencer, as well as a sig over the payload and some replay protection metadata
    KeyAndSig key_and_sig = 2;
    // Payload - signature is in key and sig
    UpdateSequencerPayload payload = 3;
}

message MsgUpdateSequencerResponse {

}
